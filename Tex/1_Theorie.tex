\subsection{Model and Implementation}
    I will desribe the model in this section in a bottom-up fashion.
    First describing all parts and then connecting them.
    %~ \subsubsection{Graphs}
        %~ A graph is a set of nodes \(V\) and edges \(E\).
    \subsubsection{Gabriel- and Relative Neighborhood Graph}
        The Gabriel Graph \cite{Gabriel1969} is a subgraph of the
        Delaunay Triangulation. Two nodes \(i\) and \(j\) with distance
        \(d_{ij}\) are connected with an edge if a circle with it's
        center on the middlepoint between \(i\) and \(j\) and radius
        \(r = \frac d 2\) contains no other nodes. This area will be
        called \emph{lune} in the following. See also Figure
        \ref{fig:def:GG}.\\
        The Relative Neighborhood Graph \cite{Toussaint1980} is a
        subgraph of the Gabriel Graph. Two nodes \(i\) and \(j\) with
        distance \(d_{ij}\) are connected if no other node is in the
        \emph{lune}. The lune is defined as the intersection of two
        circles with radius \(r = d\) and centers on \(i\) and \(j\).
        See also Figure \ref{fig:def:RNG}.\\\\
        To construct these graphs the simple way is to test for every
        pair of nodes for every node if it lies in the lune of the pair.
        That is of complexity \(\mathchar O (n^3)\).\\
        To reduce the complexity one can first create a Delaunay
        Triangulation in complexity \(\mathchar O (n \log n)\)
        \cite{Leach1992} and test the criterion for each edge, because
        the Delaunay Triangulation is a supergraph of both. But the
        implementation of a Delaunay Triangulation algorithm is not
        trivial and the generation of the graphs is not time critical.\\
        So a tradeoff is to use basicly the simple method but only test
        the criterion for nodes which are near to the lune and abort if
        one node inside the lune is found. Saving the position of every
        node in a \emph{cell list} according to \cite{RNGCell} and just
        testing the nodes in the cells which contain the lune speeds
        things up.

    \subsubsection{Model}
        The used model is a modified 2D Ising model living on a Gabriel
        or Relative Neighborhood Graph where the nodes are displaced
        nodes of a square lattice. The displacement is randomly gauss
        distributed with the standard deviation \(\sigma\). This
        \(\sigma\) is also called \emph{disturbance paramter} in the
        following.
        Each node \(i\) has a spin \(s_i = \pm 1\). Each edge has a
        weight \(J_{ij} = \exp (\alpha (1-d_{ij}))\) with the distance
        \(d_{ij}\) between the nodes \(i\) and \(j\). \(J\) is called
        \emph{interaction}. The hamiltonian of the Ising model is
        \(\hat{H} = \sum_{<i,j>}J_{ij}s_{i}s_{j}\)
        where \(<i,j>\) means nearest neighbor.
        For \(\sigma = 0\) this is the standard Ising model with
        \(J = 1\).\\\\

    \subsubsection{Algorithm}
        Monte Carlo simulations are used to obtain any properties of the
        model.
        \paragraph{Metropolis}
            A basic Monte Carlo algorithm is the Metropolis algorithm
            \cite{Metropolis1953} ... [einzelheiten]
        \paragraph{Wolff}
            Close to the critical temperature \(T_c\) the Metropolis
            gets slower. Using a cluster algorithm like the Wolff
            algorithm \cite{Wolff1989} speeds things up.
            ... [einzelheiten]
        \paragraph{Parallel Tempering}
            The main aim is to obtain the critical temperatures
            \(T_c\) for different disturbance paramters \(\sigma\).
            Therefore it is necessary to simulate for many temperatures,
            so that \emph{Parallel Tempering}\footnote{Before R. H.
                Swendsen published this paper, a algorithm \(MC^3\) was
                already published with the same idea. [citation needed]}
            \cite{ParallelTempering1986} is a suited algorithm. Parallel
            Tempering simulates many identical systems at different
            temperatures and periodically swaps the spin configurations
            between two neighboring temperatures with probability
            \(\). Some good descriptions are in
            \cite[S. ??]{NewmanBarkema1999} \cite[S. 155ff]{Katzgraber2011}.
        \paragraph{Implementation Details}
            Here a mixture of the above three algorithms is used.
            Each sweep a Metropolis sweep, a Wolff cluster step and a
            Parallel Tempering swap are performed.
        %~ Monte Carlo Simulationen:\\
            %~ Wolff-Cluster Algorithmus \cite{Wolff1989} (siehe auch \cite[S. xx]{NewmanBarkema1999}),
            %~ Metropolis Sweep \cite{Metropolis1953} (siehe auch \cite[S. xx]{NewmanBarkema1999}),
            %~ Parallel Tempering \cite{ParallelTempering1986} (siehe auch \cite[S. xx]{NewmanBarkema1999} \cite[S. xx]{Katzgraber2011})\\
